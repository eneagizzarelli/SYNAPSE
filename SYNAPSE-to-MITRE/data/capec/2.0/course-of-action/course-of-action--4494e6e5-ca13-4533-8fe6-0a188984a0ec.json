{
    "id": "bundle--2cc53347-f29c-486c-8283-b69ed2a4c400",
    "objects": [
        {
            "created": "2014-06-23T00:00:00.000Z",
            "created_by_ref": "identity--e50ab59c-5c4f-4d40-bf6a-d58418d89bcd",
            "description": "\n               <xhtml:p>The exact response required from an UTF-8 decoder on invalid input is not uniformly defined by the standards. In general, there are several ways a UTF-8 decoder might behave in the event of an invalid byte sequence:</xhtml:p>\n               <xhtml:ul>\n                  <xhtml:li>1. Insert a replacement character (e.g. '?', '').</xhtml:li>\n                  <xhtml:li>2. Ignore the bytes.</xhtml:li>\n                  <xhtml:li>3. Interpret the bytes according to a different character encoding (often the ISO-8859-1 character map).</xhtml:li>\n                  <xhtml:li>4. Not notice and decode as if the bytes were some similar bit of UTF-8.</xhtml:li>\n                  <xhtml:li>5. Stop decoding and report an error (possibly giving the caller the option to continue).</xhtml:li>\n               </xhtml:ul>\n               <xhtml:p>It is possible for a decoder to behave in different ways for different types of invalid input.</xhtml:p>\n               <xhtml:p>RFC 3629 only requires that UTF-8 decoders must not decode \"overlong sequences\" (where a character is encoded in more bytes than needed but still adheres to the forms above). The Unicode Standard requires a Unicode-compliant decoder to \"...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence.\"</xhtml:p>\n               <xhtml:p>Overlong forms are one of the most troublesome types of UTF-8 data. The current RFC says they must not be decoded but older specifications for UTF-8 only gave a warning and many simpler decoders will happily decode them. Overlong forms have been used to bypass security validations in high profile products including Microsoft's IIS web server. Therefore, great care must be taken to avoid security issues if validation is performed before conversion from UTF-8, and it is generally much simpler to handle overlong forms before any input validation is done.</xhtml:p>\n               <xhtml:p>To maintain security in the case of invalid input, there are two options. The first is to decode the UTF-8 before doing any input validation checks. The second is to use a decoder that, in the event of invalid input, returns either an error or text that the application considers to be harmless. Another possibility is to avoid conversion out of UTF-8 altogether but this relies on any other software that the data is passed to safely handling the invalid data.</xhtml:p>\n               <xhtml:p>Another consideration is error recovery. To guarantee correct recovery after corrupt or lost bytes, decoders must be able to recognize the difference between lead and trail bytes, rather than just assuming that bytes will be of the type allowed in their position.</xhtml:p>\n            ",
            "id": "course-of-action--4494e6e5-ca13-4533-8fe6-0a188984a0ec",
            "modified": "2022-09-29T00:00:00.000Z",
            "name": "coa-80-1",
            "object_marking_refs": [
                "marking-definition--17d82bb2-eeeb-4898-bda5-3ddbcd2b799d"
            ],
            "type": "course-of-action",
            "x_capec_version": "3.9"
        }
    ],
    "spec_version": "2.0",
    "type": "bundle"
}